<script>
  function randomInteger(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function getIndexColor(indexCell: number, squaresPerLine: number, lastIndexColor: number, previousLine: number[]): number {
    const t = randomInteger(-2, 2);
    if (Math.random() > 0.4) {
      // reprend une couleur de la ligne du dessus
      if (indexCell + t < 0) {
        return previousLine[Math.floor(Math.random() * squaresPerLine)];
      } else if (indexCell + t > squaresPerLine - 1) {
        return previousLine[squaresPerLine - 1];
      } else {
        return previousLine[indexCell + t];
      }
    } else if (lastIndexColor + t < 0) {
      // continue la suite de couleur
      // remonte le tableau par la fin
      return COLORS.length - 1 - lastIndexColor + t;
    } else if (lastIndexColor + t > COLORS.length) {
      // recommence au debut du tableau
      return lastIndexColor + t - COLORS.length;
    } else {
      return lastIndexColor + t;
    }
  }

  function calcMatrix(squareSize: number) {
    const index = { x: 0, y: 0 };
    const squaresPerLine = Math.ceil(screen.width / squareSize) + 1;
    const nbLines = Math.ceil(screen.height / squareSize) + 1;
    const previousLine = [] as number[];
    const table = [] as number[][];
    let lastIndexColor = 0;
    // init first line with random colors
    for (index.x = 0; index.x < squaresPerLine; index.x += 1) {
      previousLine[index.x] = Math.floor(Math.random() * COLORS.length);
    }
    // calc all lines
    for (index.y = 0; index.y < nbLines; index.y += 1) {
      for (index.x = 0; index.x < squaresPerLine; index.x += 1) {
        const indexColor = getIndexColor(index.x, squaresPerLine, lastIndexColor, previousLine);
        /* ctx!.fillStyle = COLORS[indexColor];
         ctx!.fillRect(index.x * SQUARE_SIZE, index.y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE); */
        previousLine[index.x] = indexColor;
        lastIndexColor = indexColor;
      }
      table.push([...previousLine]);
      /*  await new Promise((resolve) => {
        requestAnimationFrame(resolve);
      });  */
    }
    return { squareSize, table };
  }

  const COLORS = [
    '#141414',
    '#191919',
    '#1F1F1F',
    '#242424',
    '#292929',
    '#2E2E2E',
    '#333333',
    '#383838',
    '#3D3D3D',
    '#424242',
    '#474747',
    '#4D4D4D',
    '#525252',
    '#4D4D4D',
    '#474747',
    '#424242',
    '#3D3D3D',
    '#383838',
    '#333333',
    '#2E2E2E',
    '#292929',
    '#242424',
    '#1F1F1F',
    '#191919',
    '#141414'
  ];
  let squareSize = window.screen.width;
  const screen = { width: 800, height: 600 };

  const matrix: { squareSize: number; table: number[][] }[] = [];

  const canvas = document.querySelector('#background-canvas') as HTMLCanvasElement;

  const ctx = canvas.getContext('2d');
  const size = Math.max(window.screen.width, window.screen.height);
  screen.width = window.screen.width;
  screen.height = window.screen.height;
  canvas.width = screen.width;
  canvas.height = screen.height;

  while (squareSize > 3) {
    matrix.push(calcMatrix(squareSize));
    squareSize = Math.ceil(squareSize / 2);
  }

  while (matrix.length) {
    const m = matrix.shift();
    if (m) {
      const cells = getCells(m.table);
      while (cells.length) {
        const index = cells.splice(Math.floor(Math.random() * cells.length), 1)[0];
        ctx!.fillStyle = COLORS[m.table[index.y][index.x]];
        ctx!.fillRect(index.x * m.squareSize, index.y * m.squareSize, m.squareSize, m.squareSize);
        await new Promise((resolve) => {
          //requestAnimationFrame(resolve);
          setTimeout(resolve, 0);
        });
      }
    }
  }

  function getCells(table: number[][]) {
    const cells = [] as { x: number; y: number }[];
    table.forEach((row, iRow) => {
      row.forEach((cell, iCell) => {
        cells.push({ x: iCell, y: iRow });
      });
    });
    return cells;
  }
</script>

<canvas
  class="fixed z-0"
  id="background-canvas"></canvas>
